{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1694196600441774082",
        "title": "大四-专升本-2024 届秋招-Java 简历",
        "description": "鱼皮大佬，麻烦查看一下我简历有什么问题，我是 24 应届生，投了大厂还在筛选简历中，投了小厂未读和已读不回的 还有的需要立马就可以上班的，现在很迷茫，希望得到鱼皮大佬的一些指导",
        "content": "\n![0.jpg](https://pic.code-nav.cn/post_picture/1613125844706787330/LSKGt3QK-0.jpg)",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 40,
        "thumbNum": 1,
        "favourNum": 1,
        "commentNum": 0,
        "priority": 0,
        "userId": "1613125844706787330",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-23T03:55:20.000+00:00",
        "updateTime": "2023-08-24T02:53:26.000+00:00",
        "user": {
          "id": "1613125844706787330",
          "planetCode": "18251",
          "userName": "摆烂青年",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/Q0j4TwGTfTL5hCqcVuQCbaFFrd4LxGSvibCyEpQFyrtETvicUADW0SfIbCT0Wicc1M3zd4V8khSicqJIKHShsTgV9w/132",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-03-01T05:30:57.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-01-11T10:49:06.000+00:00",
          "updateTime": "2023-03-09T07:05:42.000+00:00"
        },
        "tags": [
          "文章",
          "简历",
          "后端"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1693943666189639682",
        "title": "Java SE 进阶 day -04 - java8 新特性 ->Stream",
        "description": "认识注解,掌握lambda,了解java8的一些新特性",
        "content": "# Stream \n**为啥学**:\n\n    简洁的代码         功能强大         易于理解\n    提高效率           更少的错误       适应现代编程需求\n    代码可读性提升     减少样板代码      与Lambda表达式配合使用\n\n\n**是什么**:\n\nStream是Java用于处理集合数据的一种新的抽象方式。它提供了一种更加简洁、灵活和功能强大的方法来处理集合中的数据。\n\n## Stream 流\n\n### 创建Stream\n#### 1. 通过集合创建 Stream\n\n使用集合类的 `stream()` 方法可以将集合转换为 Stream。\n\n```java\nList<String> names = List.of(\"Alice\", \"Bob\", \"Charlie\");\nStream<String> stream = names.stream();\n```\n#### 2. 通过数组创建 Stream\n使用 Arrays 类的 stream() 方法可以将数组转换为 Stream。\n\n```java\nString[] array = {\"apple\", \"banana\", \"orange\"};\nStream<String> stream = Arrays.stream(array);\n```\n#### 3. 通过静态方法创建 Stream\nStream 类提供了一些静态方法来创建 Stream。\n\n使用 Stream.of(T... values) 来创建一个包含多个值的 Stream。\n\n```java\nStream<Integer> stream = Stream.of(1, 2, 3, 4, 5);\n```\n使用 Stream.empty() 来创建一个空的 Stream\n```java\nStream<Object> emptyStream = Stream.empty();\n```\n\n使用 Stream.generate(Supplier< T > s) 来创建一个无限流\n\n```java\nStream<Double> randomStream = Stream.generate(Math::random);\n```\n使用Stream.iterate(T seed, UnaryOperator< T > f) 来创建一个无限流.\n\n```java\nStream<Integer> evenNumbers = Stream.iterate(0, n -> n + 2);\n```   \n#### 4. 通过文件创建 Stream\n    \n使用 Files 类的方法可以创建文件的 Stream。\n\n```java\ntry (Stream<String> lines = Files.lines(Paths.get(\"file.txt\"))) {\n    // 处理文件行内容的 Stream\n} catch (IOException e) {\n    // 处理异常\n}\n```\n\n#### 5. 通过正则表达式创建 Stream\n使用 Pattern 类的 splitAsStream 方法可以将字符串根据正则表达式分割为 Stream。\n\n```java\nPattern pattern = Pattern.compile(\",\");\nStream<String> stream = pattern.splitAsStream(\"apple,banana,orange\")\n```    \n \n### 操作Stream流\n#### 中间操作\n\n中间操作是在Java Stream上执行的操作，用于对数据进行过滤、映射、排序等转换，通常**返回一个新的Stream(开启Stream)**。以下是一些常见的中间操作及其描述：\n\n| 中间操作                  | 描述                                                                                      |\n|--------------------------|-----------------------------------------------------------------------------------------|\n| `filter(Predicate<T> p)`  | 过滤出满足给定条件的元素，生成一个包含满足条件元素的新Stream。                                |\n| `map(Function<T, R> f)`  | 将每个元素映射为新的元素，生成一个包含映射后元素的新Stream。                                  |\n| `flatMap(Function<T, Stream<R>> f)` | 将每个元素映射为Stream，然后将所有Stream合并成一个新Stream。                             |\n| `distinct()`             | 去除重复的元素，生成一个去重后的新Stream。                                                  |\n| `sorted()`               | 对Stream中的元素进行自然排序（升序），生成一个排序后的新Stream。                            |\n| `sorted(Comparator<T> c)` | 使用自定义比较器对元素进行排序，生成一个根据比较器排序后的新Stream。                      |\n| `limit(long maxSize)`    | 限制Stream的大小，使其不超过给定的元素数量，生成一个包含最多指定数量元素的新Stream。         |\n| `skip(long n)`           | 跳过前n个元素，生成一个去掉前n个元素后的新Stream。                                           |\n| `peek(Consumer<T> c)`    | 对Stream中的每个元素执行操作，但不影响元素本身，返回原Stream。                                |\n| `distinct()`             | 去除重复的元素，生成一个去重后的新Stream。                                                  |\n| `sorted()`               | 对Stream中的元素进行自然排序（升序），生成一个排序后的新Stream。                            |\n| `sorted(Comparator<T> c)` | 使用自定义比较器对元素进行排序，生成一个根据比较器排序后的新Stream。                      |\n| `limit(long maxSize)`    | 限制Stream的大小，使其不超过给定的元素数量，生成一个包含最多指定数量元素的新Stream。         |\n| `skip(long n)`           | 跳过前n个元素，生成一个去掉前n个元素后的新Stream。                                           |\n| `peek(Consumer<T> c)`    | 对Stream中的每个元素执行操作，但不影响元素本身，返回原Stream。                                |\n| `takeWhile(Predicate<T> p)` | 从开头开始，取出满足给定条件的元素，直到遇到不满足条件的元素。                               |\n| `dropWhile(Predicate<T> p)` | 从开头开始，跳过满足给定条件的元素，直到遇到不满足条件的元素。                               |\n| `mapToInt(ToIntFunction<T> mapper)` | 将元素映射为整数，并生成一个新的IntStream。                                          |\n| `mapToDouble(ToDoubleFunction<T> mapper)` | 将元素映射为双精度浮点数，并生成一个新的DoubleStream。                           |\n| `mapToLong(ToLongFunction<T> mapper)` | 将元素映射为长整型数，并生成一个新的LongStream。                                 |\n| `boxed()`                | 将基本数据类型Stream转换为装箱类型Stream。                                                |\n| `takeWhile(Predicate<T> p)` | 从开头开始，取出满足给定条件的元素，直到遇到不满足条件的元素。                               |\n| `dropWhile(Predicate<T> p)` | 从开头开始，跳过满足给定条件的元素，直到遇到不满足条件的元素。                               |\n| `mapToInt(ToIntFunction<T> mapper)` | 将元素映射为整数，并生成一个新的IntStream。                                          |\n| `mapToDouble(ToDoubleFunction<T> mapper)` | 将元素映射为双精度浮点数，并生成一个新的DoubleStream。                           |\n| `mapToLong(ToLongFunction<T> mapper)` | 将元素映射为长整型数，并生成一个新的LongStream。                                 |\n| `boxed()`                | 将基本数据类型Stream转换为装箱类型Stream。                                                |\n| `unordered()`            | 取消对Stream中元素的顺序，可能会提高某些操作的性能。                                      |\n| `onClose(Runnable closeHandler)` | 注册一个在Stream关闭时执行的操作。                                                  |\n\n这些中间操作允许你根据需要对数据进行不同类型的处理，例如筛选、转换、排序等。你可以根据具体的情况链式调用多个中间操作来构建出复杂的数据处理流程。中间操作是惰性求值的，只有在终端操作调用时才会实际执行。\n\n#### 终端操作\n终端操作是在Java Stream上执行的最终操作，它们会触发实际的计算并生成结果。(**调用后stream关闭,无法再次调用**)\n\n\n| 终端操作                 | 描述                                                                                     |\n|-------------------------|----------------------------------------------------------------------------------------|\n| `forEach(Consumer<T> action)` | 遍历Stream中的每个元素，并对每个元素执行指定的操作。                                         |\n| `toArray()`             | 将Stream中的元素转换为数组。                                                                  |\n| `collect(Collector<T, A, R> collector)` | 使用指定的收集器将Stream中的元素收集到一个结果容器中。                           |\n| `min(Comparator<T> comparator)` | 返回Stream中的最小元素，根据指定的比较器。                                      |\n| `max(Comparator<T> comparator)` | 返回Stream中的最大元素，根据指定的比较器。                                      |\n| `count()`               | 返回Stream中的元素数量。                                                                    |\n| `anyMatch(Predicate<T> predicate)` | 检查Stream中是否有任何一个元素满足给定条件。                               |\n| `allMatch(Predicate<T> predicate)` | 检查Stream中的所有元素是否都满足给定条件。                               |\n| `noneMatch(Predicate<T> predicate)` | 检查Stream中是否没有任何一个元素满足给定条件。                             |\n| `findFirst()`           | 返回Stream中的第一个元素。                                                                   |\n| `findAny()`             | 返回Stream中的任意一个元素。                                                                 |\n| `reduce(T identity, BinaryOperator<T> accumulator)` | 使用指定的初始值和累加器对Stream中的元素进行归约操作。                     |\n| `reduce(BinaryOperator<T> accumulator)` | 使用累加器对Stream中的元素进行归约操作，无初始值。                            |\n| `forEachOrdered(Consumer<T> action)` | 保留Stream中元素的遍历顺序，对每个元素执行指定的操作。                         |\n| `toArray()`             | 将Stream中的元素转换为数组。                                                                  |\n| `collect(Collector<T, A, R> collector)` | 使用指定的收集器将Stream中的元素收集到一个结果容器中。                           |\n| `count()`               | 返回Stream中的元素数量。                                                                    |\n| `min(Comparator<T> comparator)` | 返回Stream中的最小元素，根据指定的比较器。                                      |\n| `max(Comparator<T> comparator)` | 返回Stream中的最大元素，根据指定的比较器。                                      |\n| `reduce(T identity, BinaryOperator<T> accumulator)` | 使用指定的初始值和累加器对Stream中的元素进行归约操作。                     |\n| `reduce(BinaryOperator<T> accumulator)` | 使用累加器对Stream中的元素进行归约操作，无初始值。                            |\n| `reduce(U identity, BiFunction<U, ? super T, U> accumulator, BinaryOperator<U> combiner)` | 将Stream的元素累积到一个可变的结果容器中。         |\n| `anyMatch(Predicate<T> predicate)` | 检查Stream中是否有任何一个元素满足给定条件。                               |\n| `allMatch(Predicate<T> predicate)` | 检查Stream中的所有元素是否都满足给定条件。                               |\n| `noneMatch(Predicate<T> predicate)` | 检查Stream中是否没有任何一个元素满足给定条件。                             |\n| `findFirst()`           | 返回Stream中的第一个元素。                                                                   |\n| `findAny()`             | 返回Stream中的任意一个元素。                                                                 |\n| `findFirst()`          | 返回Stream中的第一个元素。                                                                  |\n| `findAny()`            | 返回Stream中的任意一个元素。                                                                |\n| `collect(Collectors.joining(delimiter))` | 将Stream中的元素用指定分隔符连接成一个字符串。            |\n| `collect(Collectors.toList())` | 将Stream中的元素收集到一个List中。                                          |\n| `collect(Collectors.toSet())` | 将Stream中的元素收集到一个Set中。                                            |\n| `collect(Collectors.toMap(keyMapper, valueMapper))` | 将Stream中的元素转换为Map。                     |\n| `collect(Collectors.groupingBy(classifier))` | 根据指定条件对Stream中的元素进行分组。                    |\n| `collect(Collectors.summarizingInt(mapper))` | 生成包含计数、总和、最小值、最大值等统计信息的对象。     |\n| `collect(Collectors.reducing(identity, mapper, operation))` | 使用指定的累加器和操作将Stream中的元素进行归约操作。 |\n| `forEachOrdered(Consumer<T> action)` | 保留Stream中元素的遍历顺序，对每个元素执行指定的操作。  |\n| `toArray()`            | 将Stream中的元素转换为数组。                                                                |\n\n##### 惰性求值\n惰性求值（Lazy Evaluation）是Java Stream的一个重要特性，它意味着在进行Stream操作时，中间操作不会立即执行，而是等到终端操作被调用时才会执行。\n\n| 特性           | 描述                                                                                         |\n|---------------|--------------------------------------------------------------------------------------------|\n| 定义处理计划    | Stream操作中的中间操作构建了一个处理计划，但在终端操作调用之前不会实际执行。                      |\n| 节省计算资源   | 由于中间操作不立即执行，避免了不必要的计算，节省了计算资源。                                   |\n| 链式调用       | 可以在一个Stream上链式调用多个操作，构建出复杂的数据处理流程，不会立即进行多次遍历。                 |\n| 优化性能       | 惰性求值允许Stream实现在内部进行一些优化，从而提高性能。                                        |\n| 适应多种场景   | 适用于处理大量数据，避免了提前将整个数据集加载到内存中。                                        |\n| 延迟执行       | 中间操作的执行被延迟到终端操作调用时。                                                       |\n| 处理计划共享   | 多次终端操作可以共享相同的中间操作计划，避免重复计算。                                           |\n\n\n##### 并发和并行\n\n**并行 (Parallelism)**：\n\n并行是指同时执行多个任务，即**多个任务在同一时刻同时进行**。在并行中，每个任务都有自己的执行线程或处理器核心，它们独立地执行任务，互不干扰。这种情况下，多个任务可以在同一时间内完全并行执行，从而可以提高系统的处理能力和性能。\n\n\n**并发 (Concurrency)**：\n\n并发是指多个任务交替执行，即**多个任务在时间上重叠进行**。在并发中，任务可能会交替使用同一资源，例如共享的内存或文件，因此需要合理地管理资源访问以避免冲突。并发通常发生在单核处理器上，通过快速切换任务的执行来创建一种“同时执行”的假象。\n### 并行流（Parallel Stream）\n\n并行流（Parallel Stream）是Java中对Stream操作的一种扩展，用于在多核处理器上并行执行Stream操作，以提高处理大量数据的效率。通过使用并行流，可以将数据分割成多个子任务，并在不同的处理单元上同时处理这些子任务，从而加速数据处理过程。\n\n| 方法                  | 类型       | 描述                                                                                                   |\n|----------------------|-----------|--------------------------------------------------------------------------------------------------------|\n| `parallelStream()`   | 中间操作 | 将一个普通的Stream转换为并行流，以便在多核处理器上并行执行操作。                                       |\n| `filter(Predicate<T> predicate)` | 中间操作 | 对并行流中的元素进行筛选，只保留满足条件的元素。                                                        |\n| `map(Function<T, R> mapper)` | 中间操作   | 对并行流中的元素进行映射转换，生成一个新的并行流。                                                       |\n| `flatMap(Function<T, Stream<R>> mapper)` | 中间操作 | 对并行流中的元素进行扁平映射转换，将每个元素映射为多个并行流并合并。                                     |\n| `distinct()`         | 中间操作   | 去除并行流中的重复元素，生成一个去重后的新并行流。                                                        |\n| `sorted()`           | 中间操作   | 对并行流中的元素进行自然排序（升序），生成一个排序后的新并行流。                                          |\n| `limit(long maxSize)` | 中间操作   | 限制并行流的大小，使其不超过给定的元素数量，生成一个包含最多指定数量元素的新并行流。                     |\n| `skip(long n)`       | 中间操作   | 跳过并行流中的前n个元素，生成一个去掉前n个元素后的新并行流。                                               |\n| `collect(Collector<T, A, R> collector)` | 终端操作 | 使用指定的收集器将并行流中的元素收集到一个结果容器中。                                                 |\n| `forEach(Consumer<T> action)` | 终端操作 | 并行遍历并行流中的每个元素，并对每个元素执行指定的操作。                                                 |\n| `count()`            | 终端操作   | 返回并行流中的元素数量。                                                                                 |\n| `min(Comparator<T> comparator)` | 终端操作 | 返回并行流中的最小元素，根据指定的比较器。                                                              |\n| `max(Comparator<T> comparator)` | 终端操作 | 返回并行流中的最大元素，根据指定的比较器。                                                              |\n| `anyMatch(Predicate<T> predicate)` | 终端操作 | 检查并行流中是否有任何一个元素满足给定条件。                                                           |\n| `allMatch(Predicate<T> predicate)` | 终端操作 | 检查并行流中的所有元素是否都满足给定条件。                                                           |\n| `noneMatch(Predicate<T> predicate)` | 终端操作 | 检查并行流中是否没有任何一个元素满足给定条件。                                                         |\n| `findFirst()`        | 终端操作   | 返回并行流中的第一个元素。                                                                               |\n| `findAny()`          | 终端操作   | 返回并行流中的任意一个元素。                                                                             |\n| `reduce(BinaryOperator<T> accumulator)` | 终端操作 | 使用累加器对并行流中的元素进行归约操作，无初始值。                                                      |\n\n\n###### 使用并行流时需要注意的问题\n\n在使用并行流进行多线程处理时，需要注意以下问题以确保正确性和性能：\n\n| 问题               | 描述                                                                                              |\n|-------------------|---------------------------------------------------------------------------------------------------|\n| 线程安全性         | 并行流操作涉及多个线程，确保在处理共享资源时采取适当的线程安全措施，如使用同步机制或并发容器。      |\n| 全局状态           | 避免在并行流操作中修改全局状态，以免导致不确定性的结果。                                       |\n| 不可变性           | 使用不可变对象或安全地共享可变对象来避免并行访问冲突。                                         |\n| 数据分区           | 并行流会将数据分区并在多个线程上并行处理，需要合理地划分数据分区，避免过大或过小的分区。           |\n| 资源消耗           | 并行流操作涉及多线程，会消耗更多的内存和CPU资源，需要根据系统资源适度控制并发线程数。             |\n| 调试困难           | 并行流的调试可能会更加困难，因为多个线程并发执行，需要谨慎排查并发问题。                          |\n| 顺序保证           | 并行流在多线程执行时，可能会导致结果的顺序不确定，一些操作可能会失去原有的顺序保证。               |\n| 数据依赖性         | 一些操作可能需要全局的数据视图，这在并行流中可能导致性能下降。                                    |\n| 并行性开销         | 并行流的线程切换和同步开销可能超过操作本身，小数据集可能反而降低性能。                           |\n| 具体场景分析       | 根据具体的数据量、操作复杂度、资源情况等综合考虑是否使用并行流，不是所有情况都适合使用。         |\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1673111457186713601/IDrBFOCE-github-mark.svg",
        "language": null,
        "viewNum": 15,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-22T11:10:16.000+00:00",
        "updateTime": "2023-08-23T23:27:36.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-08-21T13:33:18.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Java 基础",
          "笔记",
          "学习路线",
          "后端"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1693576351698755586",
        "title": "Java SE 进阶 day -03 -注解-lambda表达式-java8新特性 ",
        "description": "认识注解,掌握lambda,了解java8的一些新特性",
        "content": "# 注解\n为什么:\n\n**代码文档和说明**：可以使用注解来标记类、方法、字段等，解释它们的用途、作用和使用方式，从而使代码更加易于理解和维护。\n\n**编译时检查**： 注解可以用来强制编译时的检查，帮助你在代码级别捕捉潜在的错误。\n\n**框架和库的集成**： 可以使你更好地理解和利用这些框架和库的功能。\n\n**代码生成和自动化处理**： 注解可以用于代码生成和自动化处理。\n\n**元编程和反射**： 注解是元编程（metaprogramming）的一种形式，可以让你在运行时访问和操作代码的结构和元素。通过反射，你可以检查类、方法、字段的注解，从而在运行时做出不同的逻辑决策。\n\n**插件和扩展**： 注解可以用于开发插件和扩展，使你的代码更加灵活和可扩展。\n\n**标准化和约定**： 注解可以用来定义标准和约定，从而保持代码的一致性和可读性。\n\n## 自定义注解\n**创建自定义注解**:\n\n```java\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n\n//描述当前元素能贴的位置\n@Target({ElementType.TYPE,ElementType.METHOD,ElementType.FIELD})\n//描述当前注解能保留到的时期(3种)\n//自定义注解一般保留到运行时期\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface VIP {\n\n    String[] value() default \"0\";\n    String name() default \"haha\";\n}\n```\n\n`RetentionPolicy.SOURCE（源代码级别）： 这种保留策略表示注解只会保留在源代码中，不会被编译器写入 class 文件，也不会在运行时被反射获取。`\n\n`RetentionPolicy.CLASS（类级别）： 这种保留策略表示注解会被编译器写入 class 文件中，但在运行时不会被反射获取。默认为 CLASS。`\n\n`RetentionPolicy.RUNTIME（运行时级别）`\n\n**使用自定义注解**\n\n```java\n//如果只为value属性赋值,可以省略属性名,否则必须加属性名\n//如果没有默认参数,则必须加,否则,可以不传参数\n@VIP(value = \"xxx\",name = \"xxxix\")\npublic class Animal {\n    @VIP\n    private String name;\n@VIP\n    public void sleep(){\n\n    }\n}\n```\n\n**获取注解信息**\n\n```java\npublic class AnnotationTest {\n    @Test\n    public void testAnnotation() throws NoSuchMethodException {\n        //访问类/方法/字段上面的注解\n        Class<Animal> animalClass = Animal.class;\n\n        //判断是否有指定的注解\n        System.out.println(animalClass.isAnnotationPresent(VIP.class));\n        if(animalClass.isAnnotationPresent(VIP.class)){\n            VIP annotation = animalClass.getAnnotation(VIP.class);\n            System.out.println(annotation);\n            System.out.println(annotation.name());\n            System.out.println(Arrays.toString(annotation.value()));\n        }\n\n        //获取方法上的注解\n        Method sleep = animalClass.getMethod(\"sleep\");\n        VIP annotation = sleep.getAnnotation(VIP.class);\n        System.out.println(annotation);\n\n    }\n}\n```\n\n# lambda表达式\nLambda 表达式的引入使得 Java 代码更具表现力和可读性，能够更紧凑地表达逻辑，尤其在函数式编程风格中能够发挥出强大的作用。\n\n### 函数式编程\n\n**函数式编程**（Functional Programming，简称FP）是一种编程范式，它将计算视为数学函数的组合，强调函数的应用和变换，而不是通过改变状态和数据来实现计算。函数式编程强调将程序分解成若干小的可组合的函数单元，从而降低复杂性、提高可读性和可维护性。\n\n### lambda语法\n\n```java\n(parameters) -> expression\n或\n(parameters) -> { statements; }\n```\n\n- parameters：代表方法的参数列表。可以是空参数列表，也可以是一个或多个参数。\n- ->：称为箭头操作符，用于分隔参数列表和表达式或代码块。\n- expression：单个表达式，可以是一个计算结果的表达式。\n- { statements; }：代码块，包含一系列语句，可以包含多个语句。\n\n例子:\n\n```java\n        //IFun fun =()->{}\n        // IFun fun=(String name,int age)->{}\n        //参数的类型可省\n        //IFun fun=(name,age)->{};\n        //如果只有一个参数,()可省\n        //IFun fun=name->{};\n        //如果方法体只有一行代码,{}可省\n        //IFun fun=name-> System.out.println(name);\n        // 如果只有一个表达式,并且返回该表达式的结果 ,return 可省\n        //IFun fun=(num1,num2) ->num1+num2;\n```\n\n\n\n# 函数式接口\n\n**只要确保接⼝中有且仅有⼀个抽象⽅法即可**\n\n格式:\n```\n修饰符    interface 接⼝名称 {\n   [public abstract] 返回值类型    ⽅法名称(可选参数信息);\n      // 其他\n}\n```\n**内置函数接口:**\n\n`Consumer<T>：表示消费型接口，接收一个参数并且不返回值。`\n    \n    \n```java\nConsumer<String> consumer = (s) -> System.out.println(\"Received: \" + s);\nconsumer.accept(\"Data\");\n```\n\n`Supplier<T>：表示供给型，不接收参数，返回一个值。`\n```java\nSupplier<String> supplier = () -> \"Hello, World!\";\nString result = supplier.get();\n```\n\n`Function<T, R>：表示函数型，接收一个参数并返回一个结果.`\n\n```java\nFunction<Integer, String> function = (num) -> \"Number: \" + num;\nString result = function.apply(10);  // \"Number: 10\"\n```\n\n`Predicate<T>：表示断言型，接收一个参数并返回一个布尔值。`\n```java\nPredicate<Integer> predicate = (num) -> num > 0;\nboolean result = predicate.test(5);  // true\n```\n###### 方法引用 \n\n方法引用允许直接引用已经存在的方法作为Lambda表达式的替代，从而避免在Lambda表达式中编写重复的逻辑。\n\n\n\n引用静态方法：通过类名直接调用已经存在的静态方法。\n\n```java\n// Lambda表达式\nFunction<Integer, String> converter = (num) -> String.valueOf(num);\n\n// 方法引用\nFunction<Integer, String> converter = String::valueOf;\n```\n引用实例方法：通过实例引用调用已经存在的实例方法。\n\n```java\n// Lambda表达式\nConsumer<String> printer = (str) -> System.out.println(str);\n\n// 方法引用\nConsumer<String> printer = System.out::println;\n```\n引用特定类型的实例方法：通过类型引用调用已经存在的实例方法。\n\n```java\nList<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\");\n\n// Lambda表达式\nnames.forEach((name) -> System.out.println(name));\n\n// 方法引用\nnames.forEach(System.out::println);\n```\n引用构造方法：通过构造方法引用创建新对象。\n\n```java\n// Lambda表达式\nSupplier<String> supplier = () -> new String();\n\n// 构造方法引用\nSupplier<String> supplier = String::new;\n```\n## java8-新特性\n在JDK 1.7及更⽼的版本中，接⼝中只能包含常量与抽象⽅法两种内容，不允许包含其他。\n但是这种情况在JDK 1.8 中已经改变：接⼝中允许包含default⽅法和static⽅法并指定⽅法体的具体实现。\n**接⼝冲突**:如果有两个接⼝中都指定了default⽅法且签名⼀样，当⼀个实现类同时实现了两个接⼝\n解决:覆盖重写,以解决冲突。",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 14,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-21T10:50:42.000+00:00",
        "updateTime": "2023-08-23T02:43:01.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-08-21T13:33:18.000+00:00"
        },
        "tags": [
          "Java 基础",
          "Java",
          "笔记",
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1693142380552757250",
        "title": "Java SE 进阶 day -02 反射，属性，内省",
        "description": null,
        "content": "# 反射\n#### 为什么使用反射\n1. 动态性和灵活性：反射允许您在编写代码时不需要提前知道类的详细信息，而是在运行时动态获取。这使您能够根据需要动态创建对象、调用方法和访问字段，从而使您的代码更加灵活。\n2. 通用性和泛化：反射使您能够编写通用的代码，可以处理多个不同类型的类和对象。这在编写通用库、插件系统以及一些工具和框架时非常有用。\n3. 框架和库：许多Java框架和库，如Spring框架、Hibernate ORM、JUnit测试框架等，都使用了反射来实现依赖注入、动态代理、对象关系映射等功能。学习反射有助于更好地理解和使用这些工具。\n4. 插件和扩展：反射使得开发插件和扩展系统变得更加容易。您可以动态地加载和卸载类，从而实现模块化和可扩展的应用程序架构。\n5. 代码生成：反射允许您在运行时生成代码，这对于某些情况下需要动态生成类或方法的情况非常有用，例如生成模板代码或代理类。\n\n\n### 反射是什么\n反射是Java编程语言提供的一种机制，允许程序在运行时检查和操作类、接口、字段、方法和构造函数等。通过反射，您可以在编写代码时不需要提前知道类的详细信息，而是在运行时动态获取这些信息。这对于编写通用工具、插件系统、动态加载类以及生成代码等情况非常有用。\n###### OCP模式 开闭原则 设计模式和框架底层都会使用（面向对象）\n\n##### 常见方法及含义\n\n1. 获取Class对象：在反射中，首先需要获取要操作的类的Class对象。可以使用以下几种方法之一：\n\n```java\nCopy code\nClass<?> clazz1 = MyClass.class; // 通过类名获取\nClass<?> clazz2 = obj.getClass(); // 通过实例获取\nClass<?> clazz3 = Class.forName(\"com.example.MyClass\"); // 通过类的全限定名获取\n```\n2. 获取类信息：一旦有了Class对象，就可以获取类的详细信息，包括字段、方法、构造函数等。\n\n```java\nCopy code\nField[] fields = clazz.getDeclaredFields(); // 获取类的所有字段\nMethod[] methods = clazz.getDeclaredMethods(); // 获取类的所有方法\nConstructor<?>[] constructors = clazz.getDeclaredConstructors(); // 获取类的所有构造函数\n```\n3. 创建对象：反射允许您在运行时创建类的实例。\n```java\nCopy code\nConstructor<?> constructor = clazz.getDeclaredConstructor(parameterTypes);\nObject instance = constructor.newInstance(arguments);\n```\n4. 调用方法：您可以使用反射来调用类的方法。\n```java\nCopy code\nMethod method = clazz.getDeclaredMethod(\"methodName\", parameterTypes);\nObject result = method.invoke(instance, arguments);\n```\n5. 访问和修改字段：反射还允许您访问和修改类的字段。\n```java\nCopy code\nField field = clazz.getDeclaredField(\"fieldName\");\nfield.setAccessible(true); // 如果字段是私有的，需要设置访问权限\nObject fieldValue = field.get(instance); // 获取字段的值\nfield.set(instance, newValue); // 设置字段的值\n````\n性能和安全性考虑：尽管反射在某些情况下非常强大，但它也可能影响性能，因为许多反射操作都需要更多的处理时间。此外，反射也可能降低代码的可读性和维护性，并且由于其可以访问私有成员，可能引发安全隐患。\n\n反射在许多框架、库和工具中都得到广泛应用，例如依赖注入、ORM（对象关系映射）、动态代理等。然而，出于性能和代码可读性的考虑，最好在合适的情况下使用反射，避免过度使用。\n\n\n\n# 属性\n**属性和字段的概念：**\n\n**字段（Field）**：字段是类中声明的变量，用于存储对象的数据。字段可以是各种基本数据类型（如int、double等）或引用类型（如对象、数组等）。字段通常被声明为类的成员变量，并具有访问修饰符（public、private等）来指定其可见性。\n\n**属性（Property）**：属性是字段的高级概念，它不仅涉及到字段本身，还包括访问和修改字段值的方法。通过属性，可以在封装的前提下控制对字段的访问。属性通常由一个读取方法（getter）和一个写入方法（setter）组成。\n\n通过SetXxx/GetXxx,Xxx就是属性\n属性不是字段，有字段不一定有属性，有属性不一定有字段。\n\n参考代码:\n\n```java\npublic class Person {\n    private String name; // 字段\n\n    public String getName() { // 读取属性值的方法\n        return name;\n    }\n\n    public void setName(String name) { // 写入属性值的方法\n        this.name = name;\n    }\n}\n\n```\n\n\n\n用途和优势：\n\n1. **封装和访问控制**：通过将字段声明为私有，然后使用公共的读取和写入方法，可以实现封装，从而控制对对象内部数据的访问。这有助于维护对象的一致性和完整性。\n\n2. **数据验证和处理**：属性的写入方法（setter）可以在设置字段值之前进行数据验证和处理，确保字段值满足特定的规则和条件。\n\n3. **与面向对象编程一致性**：属性的概念与面向对象编程的思想相吻合，它强调了对象的状态和行为的封装。\n\n4. **适应性**：通过属性，可以轻松地更改底层的字段实现，而不影响使用属性的代码。这使得在不改变外部接口的情况下进行内部更改变得更加容易。\n\n# LOmbok\nLombok 是一个Java库，旨在通过在代码中添加注解来自动化生成样板代码，从而简化开发人员的工作。它可以减少冗长的getter、setter、构造函数等代码，使代码更加清晰、简洁，并提高开发效率。\n\n常用注解以及它们的作用：\n\n`@Getter 和 @Setter: 自动生成属性的 getter 和 setter 方法。`\n\n`@NoArgsConstructor: 自动生成无参构造函数。`\n\n`@AllArgsConstructor: 自动生成包含所有字段的构造函数。`\n\n`@Data: 自动添加 @Getter、@Setter、@ToString、@EqualsAndHashCode 和 @RequiredArgsConstructor 注解。`\n\n`@ToString: 自动生成 toString() 方法。`\n\n`@EqualsAndHashCode: 自动生成 equals() 和 hashCode() 方法。`\n\n`@Builder: 生成一个用于构建对象的构建器模式。`\n\n`@Slf4j: 自动生成日志记录变量。`\n\n`@NonNull: 标记字段，表示该字段不能为空，Lombok会自动生成空指针检查。`\n\n`@Value: 类似于 @Data，但将类标记为不可变的（所有字段为 final）。`\n\n\n\n# 内省\n内省（Introspection）是一种动态获取类的信息的机制，它通常通过反射来实现。内省允许在运行时检查类的属性、方法和事件，以及操作这些元素。这个概念在Java编程中被广泛用于工具、框架和应用程序中，尤其是在需要处理类的元数据和属性的情况下。\n**用途和优势：**\n\n1. **属性访问**：内省允许您检查和访问类的属性。这对于自动生成用户界面（如图形界面）中的表单字段或控制面板非常有用。通过内省，您可以动态获取类的属性列表，并为每个属性生成对应的用户界面元素。\n\n2. **属性编辑**:通过内省，您可以在运行时获取属性的读取和写入方法，并在编辑器或IDE中创建一个通用的属性编辑界面。这种情况在开发工具或可视化编程环境中非常有用。\n\n3. **代码生成**：内省可以用于自动生成代码。例如，您可以检查类的属性并生成用于序列化或反序列化对象的代码。\n\n4. **动态代理**：在某些情况下，内省可以用于生成动态代理类。这些代理类可以在运行时拦截方法调用，并执行一些预定的操作。\n\n\n**示例**\n\n\n```java\nimport java.beans.BeanInfo;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\n\npublic class IntrospectionExample {\n    public static void main(String[] args) throws Exception {\n        BeanInfo beanInfo = Introspector.getBeanInfo(Person.class);\n        PropertyDescriptor[] propertyDescriptors = beanInfo.getPropertyDescriptors();\n\n        for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n            System.out.println(\"Property: \" + propertyDescriptor.getName());\n            System.out.println(\"  getMethod: \" + propertyDescriptor.getReadMethod());\n            System.out.println(\"  setMethod: \" + propertyDescriptor.getWriteMethod());\n        }\n    }\n}\n\n```\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1673111457186713601/yVgHhOIF-github-mark.svg",
        "language": null,
        "viewNum": 11,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-20T06:06:15.000+00:00",
        "updateTime": "2023-08-22T17:04:32.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-08-21T13:33:18.000+00:00"
        },
        "tags": [
          "文章",
          "Java",
          "Java 基础",
          "笔记"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1692497950648934401",
        "title": "java SE进阶_初识单元测试和配置文件",
        "description": " 单元测试和配置文件",
        "content": "# 单元测试\n单元测试是软件开发中的一种测试方法，用于验证程序中的最小功能模块（称为“单元”）是否按预期工作。这些测试可以通过自动化的方式运行，以确保代码在进行更大规模集成前是可靠的。\n\n## 黑盒测试(功能测试)\n黑盒测试是一种测试方法，测试人员仅通过输入和输出来评估程序的功能，而不考虑内部实现细节。测试重点是确保程序按照规格说明正常运行，不考虑内部逻辑。\n\n## 白盒测试\n白盒测试是一种测试方法，测试人员考虑程序的内部逻辑和结构，编写测试用例以验证每个分支、条件和路径是否都正确执行。这种测试可以揭示代码中的逻辑错误和漏洞。\n\n\n## 程序的生命周期\n\n一个程序的生命周期包括开发、测试、发布、维护等阶段。它是指程序从概念到废弃的整个过程，涵盖了需求分析、设计、编码、测试、部署和维护等不同的阶段。\n\n#. 可重用性：遵循 DRY 原则，减少软件中的重复代码。\n2. 可拓展性：当软件需要升级增加新的功能，能够在现有的系统架构上方便地创建新的模块，而不需 要改变软件现有的结构，也不会影响已经存在的模块。\n3. 可维护性：当用户需求发生变化时，只需要修改局部的模块中的少量代码即可\n\n如何让软件系统达到上述的特点，我们对模块的要求：\n1. 结构稳定性：在软件设计阶段，把一个模块划分为更小的模块\n2. 可拓展性：当软件必须增加新的功能时，可在现有模块的基础上创建出新的模块\n3. 可组合性：若干模块经过组合，形成大系统，模块的可组合性提高软件的可重用和可维护性\n4. 高内聚性：内聚，强调一个系模块内的功能联系，每个模块只完成特点的功能.\n5. 低耦合性：耦合，模块之间相互独立，修改某一个模块，不会影响 到其他的模块。\n\n\n## Junit jar包\nJUnit是Java中最常用的单元测试框架之一，它允许开发者编写自动化的测试用例来验证代码的正确性。\n\n### 什么是jar包,及使用\n\nJAR（Java Archive）是一种用于将Java类、资源和元数据打包成一个文件的格式。它可以用于将多个类文件、配置文件和其他资源打包到一个可执行的JAR文件中。要使用JAR包，只需将其包含在Java项目的类路径中。\n### junit 的使用及注意\n使用JUnit进行单元测试通常涉及以下步骤：\n\n    1.  导入JUnit库：将JUnit的JAR包包含到项目中。\n    2.  编写测试用例：创建测试类，使用@Test注解标记要测试的方法。\n    3.  编写断言：使用JUnit提供的断言方法来验证预期输出与实际输出是否匹配。\n    4.  运行测试：执行JUnit测试，查看测试结果。\n    \n  注意: 测试方法必须是\n          \n      ①公开的public \n      ②无返回,无参数 \n      ③命明规范testXxx(Xxx是要测试的方法名)\n      ④方法开头必须要有@Test注解\n\n# 配置文件\n配置文件是用于存储程序或系统配置信息的文件，它们可以帮助在不修改代码的情况下调整应用程序的行为。(多次修改数据,防止硬编码问题)\n\n#### 常见配置文件\n常见的配置文件类型包括：\n\n`Properties文件：一种键值对形式的配置文件，通常以.properties扩展名保存。`\n\n`XML配置文件：使用XML格式存储配置信息，具有更丰富的结构。`\n\n`YAML文件：一种人类可读的数据序列化格式，用于配置信息。`\n\n### properties\nProperties文件是一种简单的配置文件格式，例如:\n\n```properties\n#键值对存储\n#附近不要存在空格或其他字符\ndatabase.url=jdbc:mysql://localhost:3306/mydb\ndatabase.username=admin\ndatabase.password=secret\n```\n\n####  解析 properties 文件\n\n## 使用resources root 存放配置文件的好处\n**统一管理**：\n\n    将配置文件放在 \"resources\" 目录下可以集中管理项目的所有配置信息。\n    这样，你可以在一个地方查找、更新和维护所有的配置文件，而不需要在代码中指定硬编码的路径。\n\n**类路径访问**：\n\n    \"resources\" 目录下的文件会被编译到项目的类路径中，这意味着你可以通过类加载器轻松地访问这些文件。\n    这使得在代码中加载配置文件变得更加简单，不需要处理绝对路径或相对路径。\n\n**避免部署问题**：\n\n    在项目中使用相对路径或绝对路径来访问配置文件可能会在不同环境中导致问题，例如，文件路径可能会因为部署位置的不同而发生变化。\n    将配置文件放在 \"resources\" 目录下可以避免这些问题，因为类路径的位置在不同环境中是一致的。\n\n**包装到 JAR 或 WAR**：\n\n       如果你将项目打包为 JAR 文件或 WAR 文件，\"resources\" 目录下的内容会被包含在这些文件中。\n       这意味着你的配置文件会与应用程序一起分发，不需要单独拷贝或配置。\n\n**方便的类加载器**：\n\n    Java 的类加载器会自动搜索类路径下的资源文件。\n    这意味着你可以通过类加载器直接加载资源，而不需要关心文件路径的问题。`\n\n\n方式一:绝对路径\n\n```java\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\npublic class AbsolutePathPropertiesParser {\n    public static void main(String[] args) {\n        Properties properties = new Properties();\n        String filePath = \"C:\\\\myproject\\\\config.properties\"; // 使用绝对路径\n\n        try (InputStream input = new FileInputStream(filePath)) {\n            properties.load(input);\n\n            String url = properties.getProperty(\"database.url\");\n            String username = properties.getProperty(\"database.username\");\n            String password = properties.getProperty(\"database.password\");\n\n            System.out.println(\"Database URL: \" + url);\n            System.out.println(\"Username: \" + username);\n            System.out.println(\"Password: \" + password);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n\n方式二:使用类加载器解析文件(推荐使用)\n```java\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\npublic class PropertiesParser {\n    public static void main(String[] args) {\n        Properties properties = new Properties();\n        try (InputStream input = new FileInputStream(\"config.properties\")) {\n            properties.load(input);\n\n            String url = properties.getProperty(\"database.url\");\n            String username = properties.getProperty(\"database.username\");\n            String password = properties.getProperty(\"database.password\");\n\n            System.out.println(\"Database URL: \" + url);\n            System.out.println(\"Username: \" + username);\n            System.out.println(\"Password: \" + password);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n```\n\n\n### xml\nXML配置文件具有更灵活的结构，例如：\n\n```xml\n<configuration>\n    <database>\n        <url>jdbc:mysql://localhost:3306/mydb</url>\n        <username>admin</username>\n        <password>secret</password>\n    </database>\n</configuration>\n```\n\n#### 解析 XML 文件\n解析 XML 文件是将XML数据转换为程序能够理解的数据结构的过程。在Java中，常用的XML解析方式有两种：DOM（文档对象模型）和SAX（简单API for XML）。\n\n将xml中所有数据,读取到内存中,通过对象封装.\n\n##### DOM（文档对象模型）方式解析\n\n```java\n@Test\npublic void testGetStudentName() throws ParserConfigurationException, IOException, SAXException {\n    // 获取Document对象\n    DocumentBuilderFactory fac = DocumentBuilderFactory.newInstance();\n    DocumentBuilder builder = fac.newDocumentBuilder();\n    Document document = builder.parse(file);\n\n    // 打印整个文档的信息，用于验证是否成功解析\n    System.out.println(document);\n\n    // 获取根元素\n    Element studentsElement = document.getDocumentElement();\n\n    // 获取所有名为 \"student\" 的元素列表\n    NodeList students = studentsElement.getElementsByTagName(\"student\");\n\n    // 获取第二个 \"student\" 元素\n    Element item = (Element) students.item(1);\n\n    // 获取 \"student\" 元素内的名为 \"name\" 的元素列表\n    NodeList name = item.getElementsByTagName(\"name\");\n\n    // 获取 \"name\" 元素\n    Node nameElement = name.item(0);\n\n    // 获取 \"name\" 元素的文本内容，即学生的姓名\n    String textContent = nameElement.getTextContent();\n    System.out.println(textContent);\n}\n\n```\n\n**DOM解析思路**:\n导入所需的DOM相关类，如 org.w3c.dom.* 和 javax.xml.parsers.*。\n\n创建一个 DocumentBuilderFactory 实例，用于创建 DocumentBuilder。\n\n使用 DocumentBuilder 解析 XML 文件，获得 Document 对象。\n\n使用 Document 对象获取根元素，并规范化文档。\n\n使用 getElementsByTagName 获取指定标签的节点列表，然后遍历列表。\n\n对于每个节点，检查其类型是否为 ELEMENT_NODE。\n\n使用 Element 对象获取子元素的文本内容，构建你想要的数据结构。\n\n\n### XML 规范约束\n**DTD（文档类型定义）：**\nDTD是一种定义XML文档结构、元素和属性的方式。它使用简单的语法来描述XML的结构和限制。\n\n**XSD（XML模式定义）：**\nXSD是一种更强大和灵活的XML约束语言，它使用XML格式本身来定义文档的结构、元素、属性、数据类型等。XSD比DTD更具表现力和扩展性。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1673111457186713601/o9SpVmkV-logo.png",
        "language": null,
        "viewNum": 13,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 1,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-18T11:25:31.000+00:00",
        "updateTime": "2023-08-22T23:43:30.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-08-21T13:33:18.000+00:00"
        },
        "tags": [
          "文章",
          "笔记",
          "Java",
          "Java 基础"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1690941975404060673",
        "title": "java学习之 IO_day01",
        "description": null,
        "content": "## File 类\n\n该类包含了**文件或者文件夹**的**创建、删除、重命名、判断是否存在等**方法。\n\n**注意** :只能获取和设置文件本身的信息（文件大小，是否可读），不能设置和获取文件里面的内容。\n\n常用方法:\n|       类型       |                  构造器                   |                             方法                             | 描述                                                         |\n| :--------------: | :---------------------------------------: | :----------------------------------------------------------: | ------------------------------------------------------------ |\n|     `File`      |    `File(String pathname)`                 |                                                              | 通过指定路径名字符串创建一个新的 `File` 对象。               |\n|                  |  `File(String parent, String child)`      |                                                              | 根据指定的父路径字符串和子路径字符串创建一个新的 `File` 对象。 |\n|                  |  `File(File parent, String child)`        |                                                              | 根据指定的父抽象路径和子路径字符串创建一个新的 `File` 对象。   |\n|                  |                                           |          `String getName()`                               | 获取文件或目录的名称。                                       |\n|                  |                                           |          `String getPath()`                               | 返回此抽象路径名的路径名字符串。                             |\n|                  |                                           |          `String getAbsolutePath()`                       | 返回此抽象路径名的绝对路径名字符串。                         |\n|                  |                                           |          `boolean exists()`                                | 测试此抽象路径名表示的文件或目录是否存在。                   |\n|                  |                                           |          `boolean isDirectory()`                           | 测试此抽象路径名表示的是否为目录。                           |\n|                  |                                           |          `boolean isFile()`                                | 测试此抽象路径名表示的是否为文件。                           |\n|                  |                                           |          `long length()`                                   | 返回由此抽象路径名表示的文件的长度。                         |\n|                  |                                           |          `long lastModified()`                             | 返回文件的最后修改时间。                                     |\n|                  |                                           |          `boolean canRead()`                               | 测试应用程序是否可以读取此抽象路径名表示的文件。             |\n|                  |                                           |          `boolean canWrite()`                              | 测试应用程序是否可以修改此抽象路径名表示的文件。             |\n|                  |                                           |          `boolean createNewFile()`                         | 当且仅当具有此名称的文件尚不存在时，创建一个新的空文件。     |\n|                  |                                           |          `boolean mkdir()`                                 | 创建由此抽象路径名命名的目录。                               |\n|                  |                                           |          `boolean mkdirs()`                                | 创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录。 |\n|                  |                                           |          `boolean delete()`                                | 删除由此抽象路径名表示的文件或目录。                         |\n\n\n基础代码遍历某个文件夹下的子目录:\n\n```java\npublic class FileDemo2 {\n  \n   public static void list(File file) {\n   \n     if (file.isDirectory()) {\n       System.out.println(file.getPath());\n       // 如果是文件夹，则继续列出\n       File[] fs = file.listFiles();\n       if (fs != null) {\n         for (File f : fs) {\n           list(f);\n      }\n     }\n    }\n     System.out.println(file);\n }\n   public static void main(String[] args) {\n      // 需求：给定一个目录(test),遍历其下的所有目录(包含子目录)和文件\n       File file = new File(\"h:\\\\test\");\n       list(file);\n }\n}\n```\n\n## 字符编码\n1. ASCII编码表\n2. 汉字太多，128个数字不能包含所有的中文汉字，那么此时就 规定使用两个字节一起来表示一个汉字。\n3. Unicode是国际统一编码。\n\n作用:让全世界的人看到信息是统一的,不会出现乱码\n\n### 字符集\n常见的字符集:\n\n1. ASCII：每个字符占一个字节，只能包含128个符号。不能表示汉字。\n2. ISO-8859-1：也称之为latin-1，占一个字节，只收录西欧语言，不能表示汉字。\n3. GB2312/GBK/GB18030：占两个字节，支持中文。\n4. ANSI：占两个字节，在Win7简体中文的操作系统中ANSI 就指的是 GBK。\n5. UTF-8：是一种针对Unicode的可变长度字符编码，是Unicode的实现方式之一，支持中文。在开 发中建议使用。\n\n编码和解码的字符集相同，才能正确解码出信息。\n\n## IO\n程序内存需要从磁盘读取数据,内存中的数据无法长久保存\n\"IO\" 代表输入输出（Input/Output）\n\n### 流(stream)\n\n是指一连串流动的数据单元(字符、字节等),是以先进先出方式发送信息的通道。\n流\"（Stream）是一种处理数据的抽象概念。\n\nIO流是Java中处理输入和输出数据的方式，它将数据视为一系列连续的字节或字符。IO流以流的方式传输数据，这意味着数据可以逐个字节（或字符）地连续读取或写入，而不必将整个数据加载到内存中。\n\n### 字节流\n\n**用途**：字节流主要用于处理非文本数据，如图像、音频、视频等二进制文件。\n\n**类别**：字节流分为输入流（InputStream）和输出流（OutputStream）两大类。\n\n**基本类**：\nFileInputStream：用于从文件中读取字节数据。\n\n```java\ntry (FileInputStream inputStream = new FileInputStream(\"input.txt\")) {\n    int byteRead;\n    while ((byteRead = inputStream.read()) != -1) {\n        System.out.print((char) byteRead); // 将字节转换为字符并输出\n    }\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n```\nFileOutputStream：用于将字节数据写入文件。\n\n```java\nString content = \"Hello, this is some content to write to the file.\";\ntry (FileOutputStream outputStream = new FileOutputStream(\"output.txt\")) {\n    byte[] bytes = content.getBytes(); // 将字符串转换为字节数组\n    outputStream.write(bytes);\n} catch (IOException e) {\n    e.printStackTrace();\n}\n\n```",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 13,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-14T04:22:37.000+00:00",
        "updateTime": "2023-08-22T00:47:09.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-08-21T13:33:18.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1690345882362421249",
        "title": "java学习之多线程",
        "description": null,
        "content": "# 多线程\n\n为什么:提高了CPU的使用率\n\n随机性原理：因为多个线程不断去抢CPU的资源，CPU就在这多个线程间进行快速的切换，造成了随机性。\n\n### 并发? 并行?\n\n**并发**是指系统能够同时处理多个任务或操作，任务可以在同一时间段内交替执行，以提高效率。(单核)\n\n**并行**是系统真正同时执行多个任务，需要多个独立的执行单元。(多核)\n\n\n### 多线程执行流程\n**1. 创建线程：使用Thread类或Runnable接口创建线程对象。**\n \n**2. 线程执行：调用线程的start()方法来启动线程，使其开始执行任务。**\n\n**3. 竞争条件：多个线程访问共享资源可能导致竞争条件，造成数据不一致。**\n\n**4. 同步机制：使用同步锁（如synchronized关键字）来保护共享资源，避免竞争条件。**\n\n**5. 线程间通信：使用等待-通知机制或其他通信方式，在线程之间传递信息。**\n\n**6. 线程结束：线程执行完任务或不再需要时，线程结束运行。**\n\n参考图:\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1673111457186713601/WLQaXEPN-image.png)\n\n\n### 实现的方式\n\n#### 继承Thread类：创建自定义线程类，继承Thread类，重写run()方法。\n\n```java\n//继承Thread\npublic class JavaThread extends Thread {\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"学java\");\n        }\n    }\n}\n```\n\n\n\n#### 实现Runnable接口：创建实现Runnable接口的类，将其传递给Thread对象。\n\n```java\n    public class Ticket implements Runnable{\n    private int count;\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            System.out.println(\"学java\");\n        }\n    }\n}\n\n```\n\n\n\n#### jion 和sleep\n##### jion 插入:强行插队\n`xxx.join()`\n\n##### sleep 睡眠:计时等待\n\n`xxx.sleep(毫秒)`\n\n\n###### 线程的优先级（了解）\n每个线程都有优先级，优先级的高低只和线程获得执行机会的次数多少有关。\n\n线程调度：\n\n\tA:分时调度\n\tB:抢占式调度;java采用第二种方案。\n        \n获取和设置线程的优先级。\n\n            默认优先级是5\n\t\t优先级范围是1-10\n\nThread对象的setPriority(int x)和getPriority()用来设置和获得优先级。\n\n###### 后台线程（了解）\n所谓后台线程，一般用于为其他线程提供服务。也称为守护线程。JVM的垃圾回收就是典型的后台线\n程。\n\njava程序默认两个线程.\n\n特点：若所有的前台线程都死亡，后台线程自动死亡。\nThread对象setDaemon(true)用来设置后台线程。\n\nsetDaemon(true)必须在start()调用前，否则抛IllegalThreadStateException异常。\n\n### 同步锁的使用方式\n\n为什么使用:不安全.\n\n线程安全问题是如何产生的呢?\n\n\t\tA:多线程环境\n\t\tB:有共享数据\n\t\tC:多条语句操作共享数据\n\n理解**同步锁对象**:\n\n\n\t非静态\t对象是this\n\t静态\t对象是当前类的字节码文件对象\n\n#### 同步代码块\n\n```java\nsynchronized(对象) {\n\t需要被同步的代码\n}\n```\n\n#### 同步方法\n\n```java\n    修饰符 synchronized 返回值 方法名(){}\n```\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 14,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-12T12:53:58.000+00:00",
        "updateTime": "2023-08-23T00:57:31.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-08-21T13:33:18.000+00:00"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      },
      {
        "id": "1689602470763929602",
        "title": "java学习之认识异常",
        "description": null,
        "content": "## 异常处理概述\n\n1. **异常（理解）**\n   - (1) 程序出现的不正常的情况。\n   - (2) 异常分类\n     - `Throwable`\n       - `Error`: 严重的问题(修改代码逻辑)\n       - `Exception`\n         - `RuntimeException`: 可以处理，也可以不处理。一般就是程序出问题了，需要改程序。\n         - 非`RuntimeException`: 需要进行处理，否则编译不通过。\n   - (3) JVM的默认处理方案\n     - 把异常的类名、原因和位置等信息输出在了控制台。\n     - 会在哪里跌倒哪里坐下来。程序停止。\n   - (4) 自己处理异常的方案\n     - A: `try...catch...finally`\n       - 变形:\n         - `try...catch...`\n         - `try...catch...catch...catch...`\n         - `try...catch...finally`\n         - `try...catch...catch...catch...finally`\n         - `try...finally`\n     - B: `throws`\n       - 把问题抛出\n     - 建议使用A处理方案。实在解决不了，使用B方案。\n   - (5) 编译时期异常和运行时期异常的区别\n     - A: 编译时期异常：必须处理，否则程序不能通过编译。\n     - B: 运行时期异常：可以处理，也可以不处理。一般不处理。\n   - (6) `throws`和`throw`的区别\n     - A: `throws`\n       - 方法声明上，后面跟的是类名，用逗号隔开，表示可能有异常。\n     - B: `throw`\n       - 方法体中，后面跟的是对象名，只能跟一个，表示有一个异常产生。\n   - (7) `finally`的面试题\n     - A: 特点及注意事项\n       - a: 被`finally`控制的代码永远会执行。\n       - b: 注意：在执行`finally`之前JVM退出了，就不会执行了。\n     - B: `final`、`finally`和`finalize`的区别\n   - C: 如果`catch`里面有`return`，`finally`还执行吗？如果执行，在`return`前还是后。\n\n### Throwable、Error、Exception 的区别\n\n在 Java 中，`Throwable`、`Error` 和 `Exception` 是三个重要的类，用于处理程序中的异常情况。它们之间的区别如下：\n\n1. **Throwable**：\n   - `Throwable` 是 Java 中所有异常的根类，它是一个顶层的异常类，其他异常类都直接或间接地继承自它。\n   - `Throwable` 有两个主要的子类：`Error` 和 `Exception`。\n\n2. **Error**：\n   - `Error` 表示严重的错误，通常是由于虚拟机运行环境出现了无法恢复的问题。\n   - 例子包括：`OutOfMemoryError`（内存不足）、`StackOverflowError`（栈溢出）等。\n   - 一般情况下，应用程序无法处理 `Error`，因为这些错误通常是系统级别的问题，程序无法从中恢复。因此，开发人员一般不会捕获或处理 `Error`。\n\n3. **Exception**：\n   - `Exception` 表示一般性的异常情况，可以被程序处理。\n   - `Exception` 又分为两类：`RuntimeException` 和非 `RuntimeException`。\n   - `RuntimeException`：这是一类特殊的异常，通常是由程序逻辑错误引起的，例如空指针异常（`NullPointerException`）、数组越界异常（`IndexOutOfBoundsException`）等。这些异常是可以通过编写更好的代码来避免的，因此 Java 不要求必须显式地捕获或处理它们。\n   - 非 `RuntimeException`：这些异常通常是由外部因素引起的，例如文件找不到异常（`FileNotFoundException`）、网络连接异常（`IOException`）等。这些异常是需要在代码中显式处理的，否则编译会出错。\n\n总之，`Throwable` 是异常体系的根类，`Error` 表示严重错误，通常无法处理，而 `Exception` 表示一般性的异常情况，分为可以不处理的 `RuntimeException` 和需要处理的非 `RuntimeException`。在实际编程中，应该根据具体情况选择捕获和处理异常。\n\n\n#### 说说throw和throws的区别(面试题)\n\n```java\nthrows:\n(1)声明抛出异常，方法本身不处理异常，而是提醒调用者处理。\n(2)定义方法时，用在方法的定义形式上\n(3)throws 用于提醒方法调用者，方法可能出现异常，也可能不出现异常。\n\nthrow: \n(1)手动抛出异常，程序员根据程序的逻辑手动抛出一个具体的异常对象。throw 异常对象;\n(2)用在方法内\n(3)如果遇到throw 方法内部一定产生异常。\n    \n```\n   \n\n",
        "category": "文章",
        "cover": null,
        "language": null,
        "viewNum": 10,
        "thumbNum": 3,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1673111457186713601",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "createTime": "2023-08-10T11:39:54.000+00:00",
        "updateTime": "2023-08-20T11:44:09.000+00:00",
        "user": {
          "id": "1673111457186713601",
          "planetCode": "24251",
          "userName": "小白学it",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1673111457186713601/deuZEvYh-v2-44a47c4b5f6b6f8cec8ee51e645736ac_720w.webp",
          "gender": null,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "cq",
          "birthday": "2002-05-14",
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "后端",
          "goal": "社招",
          "github": null,
          "blog": null,
          "score": 0,
          "coin": 0,
          "followeeNum": 4,
          "followNum": 2,
          "followStatus": null,
          "vipExpireTime": "2024-06-25T23:22:50.000+00:00",
          "lastLoginTime": null,
          "createTime": "2023-06-25T23:30:30.000+00:00",
          "updateTime": "2023-08-21T13:33:18.000+00:00"
        },
        "tags": [
          "文章",
          "笔记",
          "Java"
        ],
        "fileList": null,
        "videoList": null,
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null
      }
    ],
    "total": "144",
    "size": "10",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "15"
  },
  "message": "ok"
}